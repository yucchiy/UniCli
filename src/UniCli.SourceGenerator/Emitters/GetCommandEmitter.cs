using System.Text;
using Microsoft.CodeAnalysis;
using UniCli.SourceGenerator.Analysis;

namespace UniCli.SourceGenerator.Emitters
{
    internal static class GetCommandEmitter
    {
        public static string Emit(SettingsTypeInfo info)
        {
            var sb = new StringBuilder();
            EmitHelper.AppendAutoGeneratedHeader(sb);
            EmitHelper.AppendUsings(sb);

            var className = info.CommandPrefix.Replace(".", "") + "InspectHandler";
            var responseName = info.CommandPrefix.Replace(".", "") + "InspectResponse";
            var settingsFullName = info.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            sb.AppendLine("namespace UniCli.Server.Editor.Handlers");
            sb.AppendLine("{");

            // Handler class
            sb.AppendLine($"    public sealed class {className} : CommandHandler<Unit, {responseName}>");
            sb.AppendLine("    {");
            sb.AppendLine($"        public override string CommandName => \"{info.CommandPrefix}.Inspect\";");
            sb.AppendLine($"        public override string Description => \"Inspect all {info.CommandPrefix} values\";");
            sb.AppendLine();
            sb.AppendLine($"        protected override ValueTask<{responseName}> ExecuteAsync(Unit request)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var response = new {responseName}();");

            // Assign flat properties (skip obsolete)
            foreach (var prop in info.Properties)
            {
                if (prop.Symbol.GetMethod == null) continue;
                if (prop.IsObsolete) continue;
                var fieldName = EmitHelper.ToCamelCase(prop.PascalCaseName);
                sb.AppendLine($"            try {{ response.{fieldName} = {EmitHelper.GetValueReadExpression(prop.Symbol, settingsFullName)}; }}");
                sb.AppendLine("            catch (System.Exception) { }");
            }

            // Assign nested type properties
            foreach (var nested in info.NestedTypes)
            {
                var nestedFieldName = EmitHelper.ToCamelCase(nested.Type.Name);
                var nestedResponseName = nested.Type.Name + "Settings";
                var nestedFullName = nested.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                sb.AppendLine($"            response.{nestedFieldName} = new {responseName}.{nestedResponseName}();");

                foreach (var prop in nested.Properties)
                {
                    if (prop.Symbol.GetMethod == null) continue;
                    if (prop.IsObsolete) continue;
                    var fieldName = EmitHelper.ToCamelCase(prop.PascalCaseName);
                    sb.AppendLine($"            try {{ response.{nestedFieldName}.{fieldName} = {EmitHelper.GetValueReadExpression(prop.Symbol, nestedFullName)}; }}");
                    sb.AppendLine("            catch (System.Exception) { }");
                }
            }

            sb.AppendLine($"            return new ValueTask<{responseName}>(response);");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine();

            // Response class
            EmitResponseClass(sb, info, responseName);

            sb.AppendLine("}");
            return sb.ToString();
        }

        private static void EmitResponseClass(
            StringBuilder sb, SettingsTypeInfo info, string responseName)
        {
            sb.AppendLine("    [Serializable]");
            sb.AppendLine($"    public class {responseName}");
            sb.AppendLine("    {");

            // Flat properties (skip obsolete)
            foreach (var prop in info.Properties)
            {
                if (prop.Symbol.GetMethod == null) continue;
                if (prop.IsObsolete) continue;
                var fieldType = EmitHelper.GetResponseFieldType(prop.Symbol.Type);
                var fieldName = EmitHelper.ToCamelCase(prop.PascalCaseName);
                sb.AppendLine($"        public {fieldType} {fieldName};");
            }

            // Nested type fields
            foreach (var nested in info.NestedTypes)
            {
                var nestedFieldName = EmitHelper.ToCamelCase(nested.Type.Name);
                var nestedResponseName = nested.Type.Name + "Settings";
                sb.AppendLine($"        public {nestedResponseName} {nestedFieldName};");
            }

            // Nested response classes
            foreach (var nested in info.NestedTypes)
            {
                var nestedResponseName = nested.Type.Name + "Settings";
                sb.AppendLine();
                sb.AppendLine("        [Serializable]");
                sb.AppendLine($"        public class {nestedResponseName}");
                sb.AppendLine("        {");

                foreach (var prop in nested.Properties)
                {
                    if (prop.Symbol.GetMethod == null) continue;
                    if (prop.IsObsolete) continue;
                    var fieldType = EmitHelper.GetResponseFieldType(prop.Symbol.Type);
                    var fieldName = EmitHelper.ToCamelCase(prop.PascalCaseName);
                    sb.AppendLine($"            public {fieldType} {fieldName};");
                }

                sb.AppendLine("        }");
            }

            sb.AppendLine("    }");
        }
    }
}
